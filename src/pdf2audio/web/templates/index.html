<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pdf2audio - PDF to Audiobook</title>
    <style>
        :root {
            --bg: #1e2030;
            --surface: #282a3a;
            --surface2: #323448;
            --border: #454868;
            --text: #e8eaf6;
            --text-dim: #a0a4c0;
            --accent: #9b8afb;
            --accent-hover: #b0a3fc;
            --green: #7dd6b3;
            --red: #f28b82;
            --orange: #f5c27a;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
        }

        .container {
            max-width: 860px;
            margin: 0 auto;
            padding: 2rem 1.5rem;
        }

        header {
            text-align: center;
            margin-bottom: 2.5rem;
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        header p {
            color: var(--text-dim);
            font-size: 0.95rem;
        }

        .device-badge {
            display: inline-block;
            background: var(--surface2);
            border: 1px solid var(--border);
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            color: var(--green);
        }

        .card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .card h2 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .step-num {
            background: var(--accent);
            color: white;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: 600;
        }

        /* Upload area */
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 2.5rem;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(155, 138, 251, 0.08);
        }

        .upload-zone input { display: none; }

        .upload-zone .icon { font-size: 2rem; margin-bottom: 0.5rem; }

        .upload-zone p { color: var(--text-dim); }

        /* Settings */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 0.25rem;
        }

        select, input[type="number"] {
            width: 100%;
            padding: 0.5rem 0.75rem;
            background: var(--surface2);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9rem;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
            width: 100%;
            justify-content: center;
            padding: 0.75rem;
            margin-top: 1rem;
        }

        .btn-primary:hover { background: var(--accent-hover); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-download {
            background: var(--green);
            color: white;
            width: 100%;
            justify-content: center;
            padding: 0.85rem;
            margin-top: 1rem;
            font-size: 1rem;
            text-decoration: none;
        }

        .btn-download:hover { opacity: 0.9; }

        /* Control buttons */
        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .btn-control {
            flex: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            padding: 0.55rem 1rem;
            border: 1px solid var(--border);
            border-radius: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            background: var(--surface2);
            color: var(--text);
            transition: background 0.2s, border-color 0.2s;
        }

        .btn-control:hover { background: var(--border); }
        .btn-control:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-control.pause { border-color: var(--orange); color: var(--orange); }
        .btn-control.resume { border-color: var(--green); color: var(--green); }
        .btn-control.stop { border-color: var(--red); color: var(--red); }

        .workers-badge {
            display: inline-block;
            background: var(--surface2);
            border: 1px solid var(--border);
            padding: 0.15rem 0.5rem;
            border-radius: 0.75rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-left: 0.5rem;
        }

        /* Chapter table */
        .chapter-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .chapter-table th {
            text-align: left;
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            color: var(--text-dim);
            font-weight: 500;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .chapter-table td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            vertical-align: middle;
        }

        .chapter-table tr:last-child td { border-bottom: none; }

        /* Status indicators */
        .status-cell {
            min-width: 120px;
        }

        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-dot.pending { background: var(--text-dim); }
        .status-dot.generating { background: var(--orange); animation: pulse 1s infinite; }
        .status-dot.done { background: var(--green); }
        .status-dot.skipped { background: var(--green); }
        .status-dot.error { background: var(--red); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Chapter progress bar (within status cell) */
        .chapter-progress {
            height: 3px;
            background: var(--surface2);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 4px;
        }

        .chapter-progress .fill {
            height: 100%;
            background: var(--orange);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Audio player */
        .audio-cell audio {
            height: 44px;
            width: 100%;
            min-width: 200px;
            border-radius: 8px;
        }

        /* Progress bar */
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--surface2);
            border-radius: 3px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-bar .fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .status-text {
            text-align: center;
            color: var(--text-dim);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .hidden { display: none; }

        /* Info alert */
        .info {
            background: rgba(155, 138, 251, 0.08);
            border-left: 3px solid var(--accent);
            padding: 0.75rem 1rem;
            border-radius: 0 6px 6px 0;
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>pdf2audio</h1>
            <p>Convert PDFs to audiobooks with chapter-by-chapter output</p>
            <div class="device-badge">{{ device }} detected</div>
        </header>

        {% if not setup_done %}
        <div class="card" id="setup-card" style="border-color: var(--orange);">
            <h2>First-Time Setup</h2>
            <p>Download the TTS model files (~350 MB) to run locally. This only needs to happen once.</p>
            <button class="btn btn-primary" id="setup-btn" onclick="startSetup()" style="margin-top: 1rem;">
                Download Model Files
            </button>
            <div id="setup-progress" class="hidden" style="margin-top: 1rem;">
                <p class="status-text" id="setup-text">Starting download...</p>
                <div class="progress-bar">
                    <div class="fill" id="setup-fill" style="width: 0%"></div>
                </div>
            </div>
            <p style="color: var(--text-dim); font-size: 0.85rem; margin-top: 0.75rem;">
                After this, everything runs fully offline on your machine.
            </p>
        </div>
        {% endif %}

        <!-- Step 1: Upload -->
        <div class="card{% if not setup_done %} hidden{% endif %}" id="upload-card">
            <h2><span class="step-num">1</span> Upload PDF</h2>
            <div class="upload-zone" id="upload-zone">
                <div class="icon">&#x1F4C4;</div>
                <p><strong>Click to select</strong> or drag & drop a PDF file</p>
                <input type="file" id="file-input" accept=".pdf">
            </div>
            <div id="upload-status" class="hidden">
                <p class="status-text" id="upload-text"></p>
            </div>
        </div>

        <!-- Step 2: Configure -->
        <div class="card hidden" id="config-card">
            <h2><span class="step-num">2</span> Configure</h2>
            <div class="settings-grid">
                <div>
                    <label for="voice-select">Voice</label>
                    <select id="voice-select">
                        {% for v in local_voices %}
                        <option value="{{ v }}"{% if v == default_voice %} selected{% endif %}>{{ v }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div>
                    <label for="speed-input">Speed</label>
                    <input type="number" id="speed-input" value="1.0" min="0.5" max="2.0" step="0.1">
                </div>
                <div>
                    <label for="lang-select">Language</label>
                    <select id="lang-select">
                        <option value="a">American English</option>
                        <option value="b">British English</option>
                        <option value="f">French</option>
                        <option value="j">Japanese</option>
                    </select>
                </div>
                <div>
                    <label for="format-select">Format</label>
                    <select id="format-select" onchange="onFormatChange()">
                        <option value="wav">WAV (lossless, large)</option>
                        <option value="mp3">MP3 (compressed)</option>
                        <option value="flac">FLAC (lossless, compressed)</option>
                        <option value="ogg">OGG (compressed)</option>
                    </select>
                </div>
                <div id="quality-group" class="hidden">
                    <label for="quality-select">MP3 Quality</label>
                    <select id="quality-select">
                        <option value="high">High (192 kbps)</option>
                        <option value="medium" selected>Medium (128 kbps)</option>
                        <option value="low">Low (64 kbps)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Step 3: Chapters -->
        <div class="card hidden" id="chapters-card">
            <h2><span class="step-num">3</span> Chapters</h2>
            <div id="chapter-info"></div>
            <table class="chapter-table" id="chapter-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Title</th>
                        <th>Pages</th>
                        <th>Est.</th>
                        <th>Status</th>
                        <th>Audio</th>
                    </tr>
                </thead>
                <tbody id="chapter-tbody"></tbody>
            </table>

            <button class="btn btn-primary" id="generate-btn" onclick="startGeneration()">
                Generate Audiobook
            </button>

            <div class="info">
                Chapters are generated in parallel when possible. You can start listening to
                completed chapters while the rest are still processing. Use pause/stop controls
                to manage long jobs.
            </div>
        </div>

        <!-- Progress -->
        <div class="card hidden" id="progress-card">
            <h2>Progress <span class="workers-badge hidden" id="workers-badge"></span></h2>
            <p class="status-text" id="progress-text">Initializing...</p>
            <div class="progress-bar">
                <div class="fill" id="progress-fill" style="width: 0%"></div>
            </div>
            <div class="controls" id="job-controls">
                <button class="btn-control pause" id="btn-pause" onclick="pauseJob()">Pause</button>
                <button class="btn-control stop" id="btn-stop" onclick="stopJob()">Stop</button>
            </div>
        </div>

        <!-- Download All -->
        <div class="card hidden" id="download-card">
            <h2>Download</h2>
            <p style="color: var(--text-dim); margin-bottom: 0.5rem;">All chapters have been generated. Download the complete audiobook as a single file.</p>
            <a class="btn btn-download" id="download-all-btn" href="#">
                Download Complete Audiobook
            </a>
        </div>
    </div>

    <script>
        let currentJob = null;
        let activeJobId = null;
        let pollInterval = null;

        // Format change: show/hide quality selector
        function onFormatChange() {
            const fmt = document.getElementById('format-select').value;
            const qg = document.getElementById('quality-group');
            if (fmt === 'mp3') {
                qg.classList.remove('hidden');
            } else {
                qg.classList.add('hidden');
            }
        }

        // Setup handling
        async function startSetup() {
            const btn = document.getElementById('setup-btn');
            btn.disabled = true;
            btn.textContent = 'Downloading...';
            document.getElementById('setup-progress').classList.remove('hidden');

            try {
                const resp = await fetch('/api/setup', { method: 'POST' });
                const data = await resp.json();

                if (data.status === 'already_done') {
                    onSetupComplete();
                    return;
                }

                const setupPoll = setInterval(async () => {
                    try {
                        const sr = await fetch('/api/setup/status');
                        const sd = await sr.json();

                        const pct = sd.total > 0 ? Math.round((sd.step / sd.total) * 100) : 0;
                        document.getElementById('setup-fill').style.width = `${pct}%`;
                        document.getElementById('setup-text').textContent = sd.message || 'Downloading...';

                        if (sd.setup_complete || sd.done) {
                            clearInterval(setupPoll);
                            onSetupComplete(sd.local_voices);
                        } else if (sd.error) {
                            clearInterval(setupPoll);
                            document.getElementById('setup-text').textContent = `Error: ${sd.error}`;
                            btn.disabled = false;
                            btn.textContent = 'Retry Download';
                        }
                    } catch (e) { /* ignore transient errors */ }
                }, 1500);
            } catch (err) {
                document.getElementById('setup-text').textContent = `Failed: ${err.message}`;
                btn.disabled = false;
                btn.textContent = 'Retry Download';
            }
        }

        function onSetupComplete(voices) {
            const setupCard = document.getElementById('setup-card');
            if (setupCard) {
                setupCard.innerHTML = `
                    <h2 style="color: var(--green);">Setup Complete</h2>
                    <p>Model files downloaded. Reloading...</p>
                `;
                setTimeout(() => window.location.reload(), 1500);
            }
        }

        // Upload handling
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');

        if (uploadZone) {
            uploadZone.addEventListener('click', () => fileInput.click());
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });
            uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('dragover'));
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                if (e.dataTransfer.files.length) {
                    fileInput.files = e.dataTransfer.files;
                    handleUpload(e.dataTransfer.files[0]);
                }
            });
            fileInput.addEventListener('change', () => {
                if (fileInput.files.length) handleUpload(fileInput.files[0]);
            });
        }

        async function handleUpload(file) {
            const statusEl = document.getElementById('upload-status');
            const textEl = document.getElementById('upload-text');
            statusEl.classList.remove('hidden');
            textEl.textContent = `Uploading ${file.name}...`;

            const formData = new FormData();
            formData.append('file', file);

            try {
                const resp = await fetch('/api/upload', { method: 'POST', body: formData });
                const data = await resp.json();

                if (!resp.ok) {
                    textEl.textContent = `Error: ${data.error}`;
                    return;
                }

                currentJob = data;
                textEl.textContent = `${file.name} - ${data.pages} pages, ${data.chapters.length} chapters`;
                renderChapters(data.chapters);

                document.getElementById('config-card').classList.remove('hidden');
                document.getElementById('chapters-card').classList.remove('hidden');
            } catch (err) {
                textEl.textContent = `Upload failed: ${err.message}`;
            }
        }

        function renderChapters(chapters) {
            const tbody = document.getElementById('chapter-tbody');
            tbody.innerHTML = '';
            chapters.forEach(ch => {
                const tr = document.createElement('tr');
                tr.id = `chapter-row-${ch.index}`;
                tr.innerHTML = `
                    <td>${ch.index + 1}</td>
                    <td>${escapeHtml(ch.title)}</td>
                    <td>${ch.page_start}-${ch.page_end}</td>
                    <td>~${ch.est_minutes} min</td>
                    <td class="status-cell">
                        <div><span class="status-dot pending"></span>Pending</div>
                    </td>
                    <td class="audio-cell">-</td>
                `;
                tbody.appendChild(tr);
            });
        }

        async function startGeneration() {
            if (!currentJob) return;

            const btn = document.getElementById('generate-btn');
            btn.disabled = true;
            btn.textContent = 'Generating...';

            document.getElementById('progress-card').classList.remove('hidden');

            const body = {
                job_id: currentJob.job_id,
                upload_path: currentJob.upload_path,
                voice: document.getElementById('voice-select').value,
                speed: parseFloat(document.getElementById('speed-input').value),
                lang_code: document.getElementById('lang-select').value,
                format: document.getElementById('format-select').value,
                quality: document.getElementById('quality-select').value,
            };

            try {
                const resp = await fetch('/api/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });
                const data = await resp.json();

                if (!resp.ok) {
                    document.getElementById('progress-text').textContent = `Error: ${data.error}`;
                    return;
                }

                activeJobId = data.job_id;

                // Show workers badge
                if (data.workers > 1) {
                    const badge = document.getElementById('workers-badge');
                    badge.textContent = `${data.workers} workers`;
                    badge.classList.remove('hidden');
                }

                // Show controls
                setControlState('running');

                // Start polling
                pollInterval = setInterval(() => pollStatus(data.job_id), 1500);
            } catch (err) {
                document.getElementById('progress-text').textContent = `Failed: ${err.message}`;
            }
        }

        // Job control functions
        async function pauseJob() {
            if (!activeJobId) return;
            try {
                await fetch(`/api/pause/${activeJobId}`, { method: 'POST' });
                setControlState('paused');
            } catch (e) { /* ignore */ }
        }

        async function resumeJob() {
            if (!activeJobId) return;
            try {
                await fetch(`/api/resume/${activeJobId}`, { method: 'POST' });
                setControlState('running');
            } catch (e) { /* ignore */ }
        }

        async function stopJob() {
            if (!activeJobId) return;
            try {
                await fetch(`/api/stop/${activeJobId}`, { method: 'POST' });
                setControlState('stopped');
            } catch (e) { /* ignore */ }
        }

        function setControlState(state) {
            const controls = document.getElementById('job-controls');
            if (state === 'running') {
                controls.innerHTML = `
                    <button class="btn-control pause" onclick="pauseJob()">Pause</button>
                    <button class="btn-control stop" onclick="stopJob()">Stop</button>
                `;
            } else if (state === 'paused') {
                controls.innerHTML = `
                    <button class="btn-control resume" onclick="resumeJob()">Resume</button>
                    <button class="btn-control stop" onclick="stopJob()">Stop</button>
                `;
            } else {
                controls.innerHTML = '';
            }
        }

        // Track which chapter indices are already done (to avoid overwriting)
        const completedIndices = new Set();

        async function pollStatus(jobId) {
            try {
                const resp = await fetch(`/api/status/${jobId}`);
                const data = await resp.json();

                const total = data.total_chapters;
                const done = data.completed_chapters;
                const pct = total > 0 ? Math.round((done / total) * 100) : 0;

                document.getElementById('progress-fill').style.width = `${pct}%`;

                // Update status text based on job state
                if (data.status === 'paused') {
                    document.getElementById('progress-text').textContent =
                        `Paused - ${done}/${total} chapters complete (${pct}%)`;
                } else if (data.status === 'running') {
                    document.getElementById('progress-text').textContent =
                        `${done}/${total} chapters complete (${pct}%)`;
                }

                // Update completed chapters
                if (data.results) {
                    data.results.forEach(r => {
                        if (completedIndices.has(r.chapter_index)) return;
                        completedIndices.add(r.chapter_index);

                        const filename = r.output_path.split(/[/\\]/).pop();
                        const audioUrl = `/api/audio/${jobId}/${filename}`;
                        const statusText = r.skipped
                            ? `${r.duration_seconds}s (cached)`
                            : `${r.duration_seconds}s`;
                        const dotClass = r.skipped ? 'skipped' : 'done';
                        updateChapterStatus(r.chapter_index, dotClass, statusText, audioUrl);
                    });
                }

                // Update per-chapter progress for ALL actively generating chapters (parallel)
                if (data.chapter_progress) {
                    for (const [chIdx, cp] of Object.entries(data.chapter_progress)) {
                        if (completedIndices.has(parseInt(chIdx))) continue;

                        const chPct = cp.chars_total > 0
                            ? Math.round((cp.chars_processed / cp.chars_total) * 100) : 0;

                        const row = document.getElementById(`chapter-row-${chIdx}`);
                        if (row) {
                            const statusCell = row.cells[4];
                            statusCell.innerHTML = `
                                <div><span class="status-dot generating"></span>Generating... ${chPct}%</div>
                                <div class="chapter-progress"><div class="fill" style="width: ${chPct}%"></div></div>
                            `;
                        }
                    }
                }

                // Handle terminal states
                if (data.status === 'completed') {
                    clearInterval(pollInterval);
                    document.getElementById('progress-text').textContent = 'All chapters complete!';
                    document.getElementById('generate-btn').textContent = 'Done!';
                    setControlState('done');

                    const dlCard = document.getElementById('download-card');
                    dlCard.classList.remove('hidden');
                    document.getElementById('download-all-btn').href = `/api/download-all/${jobId}`;
                } else if (data.status === 'stopped') {
                    clearInterval(pollInterval);
                    document.getElementById('progress-text').textContent =
                        `Stopped - ${done}/${total} chapters completed`;
                    document.getElementById('generate-btn').textContent = 'Stopped';
                    setControlState('done');

                    // Show download if any chapters were generated
                    if (done > 0) {
                        const dlCard = document.getElementById('download-card');
                        dlCard.classList.remove('hidden');
                        document.getElementById('download-all-btn').href = `/api/download-all/${jobId}`;
                    }
                } else if (data.status === 'error') {
                    clearInterval(pollInterval);
                    document.getElementById('progress-text').textContent = `Error: ${data.error}`;
                    setControlState('done');
                }
            } catch (err) {
                // Ignore transient polling errors
            }
        }

        function updateChapterStatus(index, status, text, audioUrl) {
            const row = document.getElementById(`chapter-row-${index}`);
            if (!row) return;

            const cells = row.cells;
            cells[4].innerHTML = `<div><span class="status-dot ${status}"></span>${text}</div>`;

            if (audioUrl) {
                cells[5].innerHTML = `<audio controls preload="none" src="${audioUrl}"></audio>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>
